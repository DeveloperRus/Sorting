# k-ая порядковая статистика
>Вход: множество **A**, состоящая из **n** различных чисел, и число **1<=k<=n**.

>Выход: элемент **x** принадлежащий **A**, превышающий по величине ровно **k-1** других элементов этого множества.

Задачу можно решить за время **O(n\*Lg(n))**, для этого выполняют сортировку
с заданной сложностью (пирамидальная, слиянием...), а затем извлекают элемент из массива 
с индексом **k**.

Рассмотрим более эффективный алгоритм, позволяющий выполнить выборку в наихудшем случае за **O(n)**.

### Алгоритм

1. Все элементы разбиваются на группы по *n/5* элементов(не более 5).
2. По методу вставки сортируется каждая из этих групп, а затем из каждой группы выбирается медиана
3. Путем рекурсивного вызова фунции определяется *X* медиана множества *n/5* медиан.
4. Итоговый массив разбивается с помощью процедуры *Partition* из [quickSort](../QuickSort)(разбиение массива). Если
*k* на единицу превышает колличество элементов попавших в низ разбиения, то *k* это *X*. 
5. В противном случае процедура выполняется рекурсивно в нижней или верхней части разбиения. 


В файле [main.cpp](./main.cpp) представлено применение данного алгоритма в контексте задачи
[Task.pdf](./Task.pdf). 
