# Анти-QuickSort

Средняя асимптотическая сложность **quick sort** равная **O(n\*lg(n))**
и малые постоянные множители, неучтенные в формуле, делают эту сортировку
самой быстрой. Более подробное описание и реализация данной сортировки: [QuickSort](../QuickSort).  
Но так как наихудшее время работы составляет **O(n<sup><small>2</small></sup>)**, то существуют тесты, 
на которых данная сортировка работает очень долго.

В файле [main.cpp](./main.cpp) представлена программа, генерирущий один из таких тестов в контексте
 сортировки, представленной в задании [Task.pdf](./Task.pdf) (Опорный элемент - середина массива).
 
 ### Алгоритм
 
 1. Инциализация массива длины **n** элементами от **1 до n**.
 2. Выполняется операция:
 ```objectivec
 for (int i = 0; i < size; i++)
         std::swap(array[i], array[i / 2]);
 ```
 **Корректность:**   
 Анти-QuickSort на каждом шаге меняет местами последний и центральный элементы, поэтому в центре 
 оказывается самый крупный элемент. А в алгоритме Quick sort основанном на выборе центрального элемента в качестве
 опорного происходит абсолютно симметричные операции, но в другую сторону: меняет местами центральный элемент с последним, 
 так что самый крупный элемент становится последним, а затем выполняет на массиве длины на один меньшей ту же операцию. 
 Получается, что опорным всегда будет выбираться самый крупный элемент. Также стоит отметить, что процедура разбиения 
 будет делать на каждом шаге только одну смену элементов местами. 

